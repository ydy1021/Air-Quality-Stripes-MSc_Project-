{"ast":null,"code":"import { bounds, c_list } from './constants';\nfunction getColor(val) {\n  if (val === null || val === undefined || isNaN(val)) return '#e0e0e0';\n  for (let i = 0; i < bounds.length - 1; ++i) {\n    if (val >= bounds[i] && val < bounds[i + 1]) return c_list[i];\n  }\n  return c_list[c_list.length - 1];\n}\n\n// Convert RGB string to RGB array\nfunction parseRGB(rgbString) {\n  const match = rgbString.match(/rgb\\((\\d+),(\\d+),(\\d+)\\)/);\n  if (match) {\n    return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];\n  }\n  return [224, 224, 224]; // Default gray\n}\nclass PM25Canvas {\n  static renderPM25Data(ctx, gridData, projection, transform, cities, width, height) {\n    if (!ctx || !gridData || !projection) return;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    let renderedCount = 0;\n\n    // Create city position set for avoidance\n    const cityPositions = cities.map(city => {\n      const projected = projection([city.lng, city.lat]);\n      if (!projected) return null;\n\n      // Apply zoom transformation\n      const transformedX = projected[0] * transform.k + transform.x;\n      const transformedY = projected[1] * transform.k + transform.y;\n      return {\n        x: transformedX,\n        y: transformedY\n      };\n    }).filter(pos => pos !== null);\n\n    // Create ImageData object for batch pixel operations\n    const imageData = ctx.createImageData(width, height);\n    const data = imageData.data;\n\n    // Grid size (adjusted based on zoom level)\n    const baseGridSize = 2;\n    const gridSize = Math.max(1, Math.round(baseGridSize * transform.k));\n    const cityAvoidRadius = 8; // Radius around city points to avoid\n\n    // Render each grid point\n    for (const point of gridData) {\n      const projected = projection([point.lon, point.lat]);\n      if (!projected) continue;\n\n      // Apply zoom transformation\n      const transformedX = projected[0] * transform.k + transform.x;\n      const transformedY = projected[1] * transform.k + transform.y;\n\n      // Viewport clipping\n      if (transformedX < -gridSize || transformedX >= width + gridSize || transformedY < -gridSize || transformedY >= height + gridSize) continue;\n\n      // Check for collision with city points\n      const tooCloseToCity = cityPositions.some(cityPos => {\n        const distance = Math.sqrt(Math.pow(transformedX - cityPos.x, 2) + Math.pow(transformedY - cityPos.y, 2));\n        return distance < cityAvoidRadius;\n      });\n      if (tooCloseToCity) continue; // Skip grid points near cities\n\n      // Get color\n      const color = getColor(point.value);\n      const [r, g, b] = parseRGB(color);\n\n      // Enhance color saturation\n      const enhancedR = Math.min(255, Math.round(r * 1.1));\n      const enhancedG = Math.min(255, Math.round(g * 1.1));\n      const enhancedB = Math.min(255, Math.round(b * 1.1));\n\n      // Draw grid point (small rectangle)\n      const startX = Math.max(0, Math.floor(transformedX - gridSize / 2));\n      const endX = Math.min(width - 1, Math.floor(transformedX + gridSize / 2));\n      const startY = Math.max(0, Math.floor(transformedY - gridSize / 2));\n      const endY = Math.min(height - 1, Math.floor(transformedY + gridSize / 2));\n      for (let px = startX; px <= endX; px++) {\n        for (let py = startY; py <= endY; py++) {\n          const index = (py * width + px) * 4;\n          data[index] = enhancedR; // Red\n          data[index + 1] = enhancedG; // Green\n          data[index + 2] = enhancedB; // Blue\n          data[index + 3] = 180; // Alpha\n        }\n      }\n      renderedCount++;\n    }\n\n    // Draw ImageData to canvas\n    ctx.putImageData(imageData, 0, 0);\n    console.log(`Canvas rendered ${renderedCount} grid points at scale ${transform.k.toFixed(2)}`);\n  }\n}\nexport default PM25Canvas;","map":{"version":3,"names":["bounds","c_list","getColor","val","undefined","isNaN","i","length","parseRGB","rgbString","match","parseInt","PM25Canvas","renderPM25Data","ctx","gridData","projection","transform","cities","width","height","clearRect","renderedCount","cityPositions","map","city","projected","lng","lat","transformedX","k","x","transformedY","y","filter","pos","imageData","createImageData","data","baseGridSize","gridSize","Math","max","round","cityAvoidRadius","point","lon","tooCloseToCity","some","cityPos","distance","sqrt","pow","color","value","r","g","b","enhancedR","min","enhancedG","enhancedB","startX","floor","endX","startY","endY","px","py","index","putImageData","console","log","toFixed"],"sources":["E:/Master2/FYP/s2504850/Code/scripts/Dashboard/src/PM25Canvas.js"],"sourcesContent":["import { bounds, c_list } from './constants';\n\nfunction getColor(val) {\n  if (val === null || val === undefined || isNaN(val)) return '#e0e0e0';\n  for (let i = 0; i < bounds.length - 1; ++i) {\n    if (val >= bounds[i] && val < bounds[i + 1]) return c_list[i];\n  }\n  return c_list[c_list.length - 1];\n}\n\n// Convert RGB string to RGB array\nfunction parseRGB(rgbString) {\n  const match = rgbString.match(/rgb\\((\\d+),(\\d+),(\\d+)\\)/);\n  if (match) {\n    return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];\n  }\n  return [224, 224, 224]; // Default gray\n}\n\nclass PM25Canvas {\n  static renderPM25Data(ctx, gridData, projection, transform, cities, width, height) {\n    if (!ctx || !gridData || !projection) return;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    let renderedCount = 0;\n    \n    // Create city position set for avoidance\n    const cityPositions = cities.map(city => {\n      const projected = projection([city.lng, city.lat]);\n      if (!projected) return null;\n      \n      // Apply zoom transformation\n      const transformedX = projected[0] * transform.k + transform.x;\n      const transformedY = projected[1] * transform.k + transform.y;\n      \n      return { x: transformedX, y: transformedY };\n    }).filter(pos => pos !== null);\n    \n    // Create ImageData object for batch pixel operations\n    const imageData = ctx.createImageData(width, height);\n    const data = imageData.data;\n    \n    // Grid size (adjusted based on zoom level)\n    const baseGridSize = 2;\n    const gridSize = Math.max(1, Math.round(baseGridSize * transform.k));\n    const cityAvoidRadius = 8; // Radius around city points to avoid\n    \n    // Render each grid point\n    for (const point of gridData) {\n      const projected = projection([point.lon, point.lat]);\n      if (!projected) continue;\n      \n      // Apply zoom transformation\n      const transformedX = projected[0] * transform.k + transform.x;\n      const transformedY = projected[1] * transform.k + transform.y;\n      \n      // Viewport clipping\n      if (transformedX < -gridSize || transformedX >= width + gridSize || \n          transformedY < -gridSize || transformedY >= height + gridSize) continue;\n      \n      // Check for collision with city points\n      const tooCloseToCity = cityPositions.some(cityPos => {\n        const distance = Math.sqrt(\n          Math.pow(transformedX - cityPos.x, 2) + \n          Math.pow(transformedY - cityPos.y, 2)\n        );\n        return distance < cityAvoidRadius;\n      });\n      \n      if (tooCloseToCity) continue; // Skip grid points near cities\n      \n      // Get color\n      const color = getColor(point.value);\n      const [r, g, b] = parseRGB(color);\n      \n      // Enhance color saturation\n      const enhancedR = Math.min(255, Math.round(r * 1.1));\n      const enhancedG = Math.min(255, Math.round(g * 1.1));\n      const enhancedB = Math.min(255, Math.round(b * 1.1));\n      \n      // Draw grid point (small rectangle)\n      const startX = Math.max(0, Math.floor(transformedX - gridSize/2));\n      const endX = Math.min(width - 1, Math.floor(transformedX + gridSize/2));\n      const startY = Math.max(0, Math.floor(transformedY - gridSize/2));\n      const endY = Math.min(height - 1, Math.floor(transformedY + gridSize/2));\n      \n      for (let px = startX; px <= endX; px++) {\n        for (let py = startY; py <= endY; py++) {\n          const index = (py * width + px) * 4;\n          data[index] = enhancedR;     // Red\n          data[index + 1] = enhancedG; // Green\n          data[index + 2] = enhancedB; // Blue\n          data[index + 3] = 180; // Alpha\n        }\n      }\n      \n      renderedCount++;\n    }\n    \n    // Draw ImageData to canvas\n    ctx.putImageData(imageData, 0, 0);\n    \n    console.log(`Canvas rendered ${renderedCount} grid points at scale ${transform.k.toFixed(2)}`);\n  }\n}\n\nexport default PM25Canvas; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}