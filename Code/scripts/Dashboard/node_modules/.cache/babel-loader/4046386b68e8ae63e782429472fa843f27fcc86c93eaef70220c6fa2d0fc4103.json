{"ast":null,"code":"const types = {\n  BYTE: 1,\n  CHAR: 2,\n  SHORT: 3,\n  INT: 4,\n  FLOAT: 5,\n  DOUBLE: 6\n};\n/**\n * Parse a number into their respective type\n * @param type - integer that represents the type\n * @return - parsed value of the type\n */\nexport function num2str(type) {\n  switch (Number(type)) {\n    case types.BYTE:\n      return 'byte';\n    case types.CHAR:\n      return 'char';\n    case types.SHORT:\n      return 'short';\n    case types.INT:\n      return 'int';\n    case types.FLOAT:\n      return 'float';\n    case types.DOUBLE:\n      return 'double';\n    default:\n      return 'undefined';\n  }\n}\n/**\n * Parse a number type identifier to his size in bytes\n * @param type - integer that represents the type\n * @return size of the type\n */\nexport function num2bytes(type) {\n  switch (Number(type)) {\n    case types.BYTE:\n      return 1;\n    case types.CHAR:\n      return 1;\n    case types.SHORT:\n      return 2;\n    case types.INT:\n      return 4;\n    case types.FLOAT:\n      return 4;\n    case types.DOUBLE:\n      return 8;\n    default:\n      return -1;\n  }\n}\n/**\n * Reverse search of num2str\n * @param type - string that represents the type\n * @return parsed value of the type\n */\nexport function str2num(type) {\n  switch (String(type)) {\n    case 'byte':\n      return types.BYTE;\n    case 'char':\n      return types.CHAR;\n    case 'short':\n      return types.SHORT;\n    case 'int':\n      return types.INT;\n    case 'float':\n      return types.FLOAT;\n    case 'double':\n      return types.DOUBLE;\n    /* istanbul ignore next */\n    default:\n      return -1;\n  }\n}\n/**\n * Auxiliary function to read numeric data\n * @param size - Size of the element to read\n * @param bufferReader - Function to read next value\n * @return\n */\nfunction readNumber(size, bufferReader) {\n  if (size !== 1) {\n    const numbers = new Array(size);\n    for (let i = 0; i < size; i++) {\n      numbers[i] = bufferReader();\n    }\n    return numbers;\n  } else {\n    return bufferReader();\n  }\n}\n/**\n * Given a type and a size reads the next element\n * @param buffer - Buffer for the file data\n * @param type - Type of the data to read\n * @param size - Size of the element to read\n * @return\n */\nexport function readType(buffer, type, size) {\n  switch (type) {\n    case types.BYTE:\n      return Array.from(buffer.readBytes(size));\n    case types.CHAR:\n      return trimNull(buffer.readChars(size));\n    case types.SHORT:\n      return readNumber(size, buffer.readInt16.bind(buffer));\n    case types.INT:\n      return readNumber(size, buffer.readInt32.bind(buffer));\n    case types.FLOAT:\n      return readNumber(size, buffer.readFloat32.bind(buffer));\n    case types.DOUBLE:\n      return readNumber(size, buffer.readFloat64.bind(buffer));\n    default:\n      throw new Error(`non valid type ${type}`);\n  }\n}\n/**\n * Removes null terminate value\n * @param value - String to trim\n * @return - Trimmed string\n */\nfunction trimNull(value) {\n  if (value.charCodeAt(value.length - 1) === 0) {\n    return value.substring(0, value.length - 1);\n  }\n  return value;\n}","map":{"version":3,"names":["types","BYTE","CHAR","SHORT","INT","FLOAT","DOUBLE","num2str","type","Number","num2bytes","str2num","String","readNumber","size","bufferReader","numbers","Array","i","readType","buffer","from","readBytes","trimNull","readChars","readInt16","bind","readInt32","readFloat32","readFloat64","Error","value","charCodeAt","length","substring"],"sources":["E:\\Master2\\FYP\\Global\\Global\\dashboard_ComparisionVersion\\node_modules\\netcdfjs\\src\\types.ts"],"sourcesContent":["import { IOBuffer } from 'iobuffer';\n\nconst types = {\n  BYTE: 1,\n  CHAR: 2,\n  SHORT: 3,\n  INT: 4,\n  FLOAT: 5,\n  DOUBLE: 6,\n};\n\n/**\n * Parse a number into their respective type\n * @param type - integer that represents the type\n * @return - parsed value of the type\n */\nexport function num2str(type: number): string {\n  switch (Number(type)) {\n    case types.BYTE:\n      return 'byte';\n    case types.CHAR:\n      return 'char';\n    case types.SHORT:\n      return 'short';\n    case types.INT:\n      return 'int';\n    case types.FLOAT:\n      return 'float';\n    case types.DOUBLE:\n      return 'double';\n    default:\n      return 'undefined';\n  }\n}\n\n/**\n * Parse a number type identifier to his size in bytes\n * @param type - integer that represents the type\n * @return size of the type\n */\nexport function num2bytes(type: number): number {\n  switch (Number(type)) {\n    case types.BYTE:\n      return 1;\n    case types.CHAR:\n      return 1;\n    case types.SHORT:\n      return 2;\n    case types.INT:\n      return 4;\n    case types.FLOAT:\n      return 4;\n    case types.DOUBLE:\n      return 8;\n    default:\n      return -1;\n  }\n}\n\n/**\n * Reverse search of num2str\n * @param type - string that represents the type\n * @return parsed value of the type\n */\nexport function str2num(type: string) {\n  switch (String(type)) {\n    case 'byte':\n      return types.BYTE;\n    case 'char':\n      return types.CHAR;\n    case 'short':\n      return types.SHORT;\n    case 'int':\n      return types.INT;\n    case 'float':\n      return types.FLOAT;\n    case 'double':\n      return types.DOUBLE;\n    /* istanbul ignore next */\n    default:\n      return -1;\n  }\n}\n\n/**\n * Auxiliary function to read numeric data\n * @param size - Size of the element to read\n * @param bufferReader - Function to read next value\n * @return\n */\nfunction readNumber(\n  size: number,\n  bufferReader: () => number,\n): number | number[] {\n  if (size !== 1) {\n    const numbers = new Array(size);\n    for (let i = 0; i < size; i++) {\n      numbers[i] = bufferReader();\n    }\n    return numbers;\n  } else {\n    return bufferReader();\n  }\n}\n\n/**\n * Given a type and a size reads the next element\n * @param buffer - Buffer for the file data\n * @param type - Type of the data to read\n * @param size - Size of the element to read\n * @return\n */\nexport function readType(\n  buffer: IOBuffer,\n  type: number,\n  size: number,\n): string | number | number[] {\n  switch (type) {\n    case types.BYTE:\n      return Array.from(buffer.readBytes(size));\n    case types.CHAR:\n      return trimNull(buffer.readChars(size));\n    case types.SHORT:\n      return readNumber(size, buffer.readInt16.bind(buffer));\n    case types.INT:\n      return readNumber(size, buffer.readInt32.bind(buffer));\n    case types.FLOAT:\n      return readNumber(size, buffer.readFloat32.bind(buffer));\n    case types.DOUBLE:\n      return readNumber(size, buffer.readFloat64.bind(buffer));\n    default:\n      throw new Error(`non valid type ${type}`);\n  }\n}\n\n/**\n * Removes null terminate value\n * @param value - String to trim\n * @return - Trimmed string\n */\nfunction trimNull(value: string): string {\n  if (value.charCodeAt(value.length - 1) === 0) {\n    return value.substring(0, value.length - 1);\n  }\n  return value;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}