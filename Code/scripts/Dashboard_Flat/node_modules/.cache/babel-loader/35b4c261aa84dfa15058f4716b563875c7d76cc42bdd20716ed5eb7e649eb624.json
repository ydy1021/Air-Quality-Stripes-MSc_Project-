{"ast":null,"code":"import { IOBuffer } from 'iobuffer';\nimport { record, nonRecord } from './data';\nimport { header } from './header';\nimport { toString } from './toString';\nimport { notNetcdf } from './utils';\n/**\n * Reads a NetCDF v3.x file\n * [See specification](https://www.unidata.ucar.edu/software/netcdf/docs/file_format_specifications.html)\n * @param data - ArrayBuffer or any Typed Array (including Node.js' Buffer from v4) with the data\n * @constructor\n */\nexport class NetCDFReader {\n  constructor(data) {\n    this.toString = toString;\n    const buffer = new IOBuffer(data);\n    buffer.setBigEndian();\n    // Validate that it's a NetCDF file\n    notNetcdf(buffer.readChars(3) !== 'CDF', 'should start with CDF');\n    // Check the NetCDF format\n    const version = buffer.readByte();\n    notNetcdf(version > 2, 'unknown version');\n    // Read the header\n    this.header = header(buffer, version);\n    this.buffer = buffer;\n  }\n  /**\n   * @return - Version for the NetCDF format\n   */\n  get version() {\n    if (this.header.version === 1) {\n      return 'classic format';\n    } else {\n      return '64-bit offset format';\n    }\n  }\n  /**\n   * @return {object} - Metadata for the record dimension\n   *  * `length`: Number of elements in the record dimension\n   *  * `id`: Id number in the list of dimensions for the record dimension\n   *  * `name`: String with the name of the record dimension\n   *  * `recordStep`: Number with the record variables step size\n   */\n  get recordDimension() {\n    return this.header.recordDimension;\n  }\n  /**\n   * @return - Array - List of dimensions with:\n   *  * `name`: String with the name of the dimension\n   *  * `size`: Number with the size of the dimension\n   */\n  get dimensions() {\n    return this.header.dimensions;\n  }\n  /**\n   * @return - Array - List of global attributes with:\n   *  * `name`: String with the name of the attribute\n   *  * `type`: String with the type of the attribute\n   *  * `value`: A number or string with the value of the attribute\n   */\n  get globalAttributes() {\n    return this.header.globalAttributes;\n  }\n  /**\n   * Returns the value of an attribute\n   * @param - AttributeName\n   * @return - Value of the attributeName or null\n   */\n  getAttribute(attributeName) {\n    const attribute = this.globalAttributes.find(val => val.name === attributeName);\n    if (attribute) return attribute.value;\n    return null;\n  }\n  /**\n   * Returns the value of a variable as a string\n   * @param - variableName\n   * @return - Value of the variable as a string or null\n   */\n  getDataVariableAsString(variableName) {\n    const variable = this.getDataVariable(variableName);\n    if (variable) return variable.join('');\n    return null;\n  }\n  get variables() {\n    return this.header.variables;\n  }\n  /**\n   * Retrieves the data for a given variable\n   * @param variableName - Name of the variable to search or variable object\n   * @return The variable values\n   */\n  getDataVariable(variableName) {\n    let variable;\n    if (typeof variableName === 'string') {\n      // search the variable\n      variable = this.header.variables.find(val => {\n        return val.name === variableName;\n      });\n    } else {\n      variable = variableName;\n    }\n    // throws if variable not found\n    if (variable === undefined) {\n      throw new Error('Not a valid NetCDF v3.x file: variable not found');\n    }\n    // go to the offset position\n    this.buffer.seek(variable.offset);\n    if (variable.record) {\n      // record variable case\n      return record(this.buffer, variable, this.header.recordDimension);\n    } else {\n      // non-record variable case\n      return nonRecord(this.buffer, variable);\n    }\n  }\n  /**\n   * Check if a dataVariable exists\n   * @param variableName - Name of the variable to find\n   * @return boolean\n   */\n  dataVariableExists(variableName) {\n    const variable = this.header.variables.find(val => {\n      return val.name === variableName;\n    });\n    return variable !== undefined;\n  }\n  /**\n   * Check if an attribute exists\n   * @param attributeName - Name of the attribute to find\n   * @return boolean\n   */\n  attributeExists(attributeName) {\n    const attribute = this.globalAttributes.find(val => val.name === attributeName);\n    return attribute !== undefined;\n  }\n}","map":{"version":3,"names":["IOBuffer","record","nonRecord","header","toString","notNetcdf","NetCDFReader","constructor","data","buffer","setBigEndian","readChars","version","readByte","recordDimension","dimensions","globalAttributes","getAttribute","attributeName","attribute","find","val","name","value","getDataVariableAsString","variableName","variable","getDataVariable","join","variables","undefined","Error","seek","offset","dataVariableExists","attributeExists"],"sources":["E:\\Master2\\FYP\\Global\\Global\\dashboard_ComparisionVersion\\node_modules\\netcdfjs\\src\\parser.ts"],"sourcesContent":["import { IOBuffer } from 'iobuffer';\n\nimport { record, nonRecord } from './data';\nimport { Header, header } from './header';\nimport { toString } from './toString';\nimport { notNetcdf } from './utils';\n\n/**\n * Reads a NetCDF v3.x file\n * [See specification](https://www.unidata.ucar.edu/software/netcdf/docs/file_format_specifications.html)\n * @param data - ArrayBuffer or any Typed Array (including Node.js' Buffer from v4) with the data\n * @constructor\n */\nexport class NetCDFReader {\n  public header: Header;\n  public buffer: IOBuffer;\n\n  constructor(data: BinaryData) {\n    const buffer = new IOBuffer(data);\n    buffer.setBigEndian();\n\n    // Validate that it's a NetCDF file\n    notNetcdf(buffer.readChars(3) !== 'CDF', 'should start with CDF');\n\n    // Check the NetCDF format\n    const version = buffer.readByte();\n    notNetcdf(version > 2, 'unknown version');\n\n    // Read the header\n    this.header = header(buffer, version);\n    this.buffer = buffer;\n  }\n\n  /**\n   * @return - Version for the NetCDF format\n   */\n  get version() {\n    if (this.header.version === 1) {\n      return 'classic format';\n    } else {\n      return '64-bit offset format';\n    }\n  }\n\n  /**\n   * @return {object} - Metadata for the record dimension\n   *  * `length`: Number of elements in the record dimension\n   *  * `id`: Id number in the list of dimensions for the record dimension\n   *  * `name`: String with the name of the record dimension\n   *  * `recordStep`: Number with the record variables step size\n   */\n  get recordDimension() {\n    return this.header.recordDimension;\n  }\n\n  /**\n   * @return - Array - List of dimensions with:\n   *  * `name`: String with the name of the dimension\n   *  * `size`: Number with the size of the dimension\n   */\n  get dimensions() {\n    return this.header.dimensions;\n  }\n\n  /**\n   * @return - Array - List of global attributes with:\n   *  * `name`: String with the name of the attribute\n   *  * `type`: String with the type of the attribute\n   *  * `value`: A number or string with the value of the attribute\n   */\n  get globalAttributes(): Header['globalAttributes'] {\n    return this.header.globalAttributes;\n  }\n\n  /**\n   * Returns the value of an attribute\n   * @param - AttributeName\n   * @return - Value of the attributeName or null\n   */\n  getAttribute(attributeName: string) {\n    const attribute = this.globalAttributes.find(\n      (val) => val.name === attributeName,\n    );\n    if (attribute) return attribute.value;\n    return null;\n  }\n\n  /**\n   * Returns the value of a variable as a string\n   * @param - variableName\n   * @return - Value of the variable as a string or null\n   */\n  getDataVariableAsString(variableName: string) {\n    const variable = this.getDataVariable(variableName);\n    if (variable) return variable.join('');\n    return null;\n  }\n\n  get variables() {\n    return this.header.variables;\n  }\n\n  toString = toString;\n\n  /**\n   * Retrieves the data for a given variable\n   * @param variableName - Name of the variable to search or variable object\n   * @return The variable values\n   */\n  getDataVariable(variableName: string | Header['variables'][number]) {\n    let variable;\n    if (typeof variableName === 'string') {\n      // search the variable\n      variable = this.header.variables.find((val) => {\n        return val.name === variableName;\n      });\n    } else {\n      variable = variableName;\n    }\n\n    // throws if variable not found\n    if (variable === undefined) {\n      throw new Error('Not a valid NetCDF v3.x file: variable not found');\n    }\n\n    // go to the offset position\n    this.buffer.seek(variable.offset);\n\n    if (variable.record) {\n      // record variable case\n      return record(this.buffer, variable, this.header.recordDimension);\n    } else {\n      // non-record variable case\n      return nonRecord(this.buffer, variable);\n    }\n  }\n\n  /**\n   * Check if a dataVariable exists\n   * @param variableName - Name of the variable to find\n   * @return boolean\n   */\n  dataVariableExists(variableName: string) {\n    const variable = this.header.variables.find((val) => {\n      return val.name === variableName;\n    });\n    return variable !== undefined;\n  }\n\n  /**\n   * Check if an attribute exists\n   * @param attributeName - Name of the attribute to find\n   * @return boolean\n   */\n  attributeExists(attributeName: string) {\n    const attribute = this.globalAttributes.find(\n      (val) => val.name === attributeName,\n    );\n    return attribute !== undefined;\n  }\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,UAAU;AAEnC,SAASC,MAAM,EAAEC,SAAS,QAAQ,QAAQ;AAC1C,SAAiBC,MAAM,QAAQ,UAAU;AACzC,SAASC,QAAQ,QAAQ,YAAY;AACrC,SAASC,SAAS,QAAQ,SAAS;AAEnC;;;;;;AAMA,OAAM,MAAOC,YAAY;EAIvBC,YAAYC,IAAgB;IAqF5B,KAAAJ,QAAQ,GAAGA,QAAQ;IApFjB,MAAMK,MAAM,GAAG,IAAIT,QAAQ,CAACQ,IAAI,CAAC;IACjCC,MAAM,CAACC,YAAY,EAAE;IAErB;IACAL,SAAS,CAACI,MAAM,CAACE,SAAS,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE,uBAAuB,CAAC;IAEjE;IACA,MAAMC,OAAO,GAAGH,MAAM,CAACI,QAAQ,EAAE;IACjCR,SAAS,CAACO,OAAO,GAAG,CAAC,EAAE,iBAAiB,CAAC;IAEzC;IACA,IAAI,CAACT,MAAM,GAAGA,MAAM,CAACM,MAAM,EAAEG,OAAO,CAAC;IACrC,IAAI,CAACH,MAAM,GAAGA,MAAM;EACtB;EAEA;;;EAGA,IAAIG,OAAOA,CAAA;IACT,IAAI,IAAI,CAACT,MAAM,CAACS,OAAO,KAAK,CAAC,EAAE;MAC7B,OAAO,gBAAgB;KACxB,MAAM;MACL,OAAO,sBAAsB;;EAEjC;EAEA;;;;;;;EAOA,IAAIE,eAAeA,CAAA;IACjB,OAAO,IAAI,CAACX,MAAM,CAACW,eAAe;EACpC;EAEA;;;;;EAKA,IAAIC,UAAUA,CAAA;IACZ,OAAO,IAAI,CAACZ,MAAM,CAACY,UAAU;EAC/B;EAEA;;;;;;EAMA,IAAIC,gBAAgBA,CAAA;IAClB,OAAO,IAAI,CAACb,MAAM,CAACa,gBAAgB;EACrC;EAEA;;;;;EAKAC,YAAYA,CAACC,aAAqB;IAChC,MAAMC,SAAS,GAAG,IAAI,CAACH,gBAAgB,CAACI,IAAI,CACzCC,GAAG,IAAKA,GAAG,CAACC,IAAI,KAAKJ,aAAa,CACpC;IACD,IAAIC,SAAS,EAAE,OAAOA,SAAS,CAACI,KAAK;IACrC,OAAO,IAAI;EACb;EAEA;;;;;EAKAC,uBAAuBA,CAACC,YAAoB;IAC1C,MAAMC,QAAQ,GAAG,IAAI,CAACC,eAAe,CAACF,YAAY,CAAC;IACnD,IAAIC,QAAQ,EAAE,OAAOA,QAAQ,CAACE,IAAI,CAAC,EAAE,CAAC;IACtC,OAAO,IAAI;EACb;EAEA,IAAIC,SAASA,CAAA;IACX,OAAO,IAAI,CAAC1B,MAAM,CAAC0B,SAAS;EAC9B;EAIA;;;;;EAKAF,eAAeA,CAACF,YAAkD;IAChE,IAAIC,QAAQ;IACZ,IAAI,OAAOD,YAAY,KAAK,QAAQ,EAAE;MACpC;MACAC,QAAQ,GAAG,IAAI,CAACvB,MAAM,CAAC0B,SAAS,CAACT,IAAI,CAAEC,GAAG,IAAI;QAC5C,OAAOA,GAAG,CAACC,IAAI,KAAKG,YAAY;MAClC,CAAC,CAAC;KACH,MAAM;MACLC,QAAQ,GAAGD,YAAY;;IAGzB;IACA,IAAIC,QAAQ,KAAKI,SAAS,EAAE;MAC1B,MAAM,IAAIC,KAAK,CAAC,kDAAkD,CAAC;;IAGrE;IACA,IAAI,CAACtB,MAAM,CAACuB,IAAI,CAACN,QAAQ,CAACO,MAAM,CAAC;IAEjC,IAAIP,QAAQ,CAACzB,MAAM,EAAE;MACnB;MACA,OAAOA,MAAM,CAAC,IAAI,CAACQ,MAAM,EAAEiB,QAAQ,EAAE,IAAI,CAACvB,MAAM,CAACW,eAAe,CAAC;KAClE,MAAM;MACL;MACA,OAAOZ,SAAS,CAAC,IAAI,CAACO,MAAM,EAAEiB,QAAQ,CAAC;;EAE3C;EAEA;;;;;EAKAQ,kBAAkBA,CAACT,YAAoB;IACrC,MAAMC,QAAQ,GAAG,IAAI,CAACvB,MAAM,CAAC0B,SAAS,CAACT,IAAI,CAAEC,GAAG,IAAI;MAClD,OAAOA,GAAG,CAACC,IAAI,KAAKG,YAAY;IAClC,CAAC,CAAC;IACF,OAAOC,QAAQ,KAAKI,SAAS;EAC/B;EAEA;;;;;EAKAK,eAAeA,CAACjB,aAAqB;IACnC,MAAMC,SAAS,GAAG,IAAI,CAACH,gBAAgB,CAACI,IAAI,CACzCC,GAAG,IAAKA,GAAG,CAACC,IAAI,KAAKJ,aAAa,CACpC;IACD,OAAOC,SAAS,KAAKW,SAAS;EAChC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}