{"ast":null,"code":"import { num2str, readType } from './types';\nimport { padding, notNetcdf, readName } from './utils';\n// Grammar constants\nconst ZERO = 0;\nconst NC_DIMENSION = 10;\nconst NC_VARIABLE = 11;\nconst NC_ATTRIBUTE = 12;\nconst NC_UNLIMITED = 0;\n/**\n * Reads the file header as @see {@link Header}\n * @param buffer - Buffer for the file data\n * @param version - Version of the file\n * @returns\n */\nexport function header(buffer, version) {\n  const header = {\n    version\n  };\n  const recordDimension = {\n    length: buffer.readUint32()\n  };\n  const dimList = dimensionsList(buffer);\n  if (!Array.isArray(dimList)) {\n    recordDimension.id = dimList.recordId;\n    recordDimension.name = dimList.recordName;\n    header.dimensions = dimList.dimensions;\n  }\n  header.globalAttributes = attributesList(buffer);\n  const variables = variablesList(buffer, recordDimension?.id, version);\n  if (!Array.isArray(variables)) {\n    header.variables = variables.variables;\n    recordDimension.recordStep = variables.recordStep;\n  }\n  header.recordDimension = recordDimension;\n  return header;\n}\n/**\n * List of dimensions\n * @param buffer - Buffer for the file data\n * @return List of dimensions\n */\nfunction dimensionsList(buffer) {\n  const result = {};\n  let recordId, recordName;\n  const dimList = buffer.readUint32();\n  let dimensions;\n  if (dimList === ZERO) {\n    notNetcdf(buffer.readUint32() !== ZERO, 'wrong empty tag for list of dimensions');\n    return [];\n  } else {\n    notNetcdf(dimList !== NC_DIMENSION, 'wrong tag for list of dimensions');\n    // Length of dimensions\n    const dimensionSize = buffer.readUint32();\n    dimensions = new Array(dimensionSize);\n    //populate `name` and `size` for each dimension\n    for (let dim = 0; dim < dimensionSize; dim++) {\n      // Read name\n      const name = readName(buffer);\n      // Read dimension size\n      const size = buffer.readUint32();\n      if (size === NC_UNLIMITED) {\n        // in netcdf 3 one field can be of size unlimited\n        recordId = dim;\n        recordName = name;\n      }\n      dimensions[dim] = {\n        name,\n        size\n      };\n    }\n  }\n  if (recordId !== undefined) {\n    result.recordId = recordId;\n  }\n  if (recordName !== undefined) {\n    result.recordName = recordName;\n  }\n  result.dimensions = dimensions;\n  return result;\n}\n/**\n * List of attributes\n * @param buffer - Buffer for the file data\n * @return - List of attributes with:\n */\nfunction attributesList(buffer) {\n  const gAttList = buffer.readUint32();\n  let attributes;\n  if (gAttList === ZERO) {\n    notNetcdf(buffer.readUint32() !== ZERO, 'wrong empty tag for list of attributes');\n    return [];\n  } else {\n    notNetcdf(gAttList !== NC_ATTRIBUTE, 'wrong tag for list of attributes');\n    // Length of attributes\n    const attributeSize = buffer.readUint32();\n    attributes = new Array(attributeSize);\n    // Populate `name`, `type` and `value` for each attribute\n    for (let gAtt = 0; gAtt < attributeSize; gAtt++) {\n      // Read name\n      const name = readName(buffer);\n      // Read type\n      const type = buffer.readUint32();\n      notNetcdf(type < 1 || type > 6, `non valid type ${type}`);\n      // Read attribute\n      const size = buffer.readUint32();\n      const value = readType(buffer, type, size);\n      // Apply padding\n      padding(buffer);\n      attributes[gAtt] = {\n        name,\n        type: num2str(type),\n        value\n      };\n    }\n  }\n  return attributes;\n}\n/**\n * @param buffer - Buffer for the file data\n * @param recordId - Id of the unlimited dimension (also called record dimension)\n * This value may be undefined if there is no unlimited dimension\n * @param version - Version of the file\n * @return - Number of recordStep and list of variables @see {@link Variables}\n */\nfunction variablesList(buffer, recordId, version) {\n  const varList = buffer.readUint32();\n  let recordStep = 0;\n  let variables;\n  if (varList === ZERO) {\n    notNetcdf(buffer.readUint32() !== ZERO, 'wrong empty tag for list of variables');\n    return [];\n  } else {\n    notNetcdf(varList !== NC_VARIABLE, 'wrong tag for list of variables');\n    // Length of variables\n    const variableSize = buffer.readUint32();\n    variables = new Array(variableSize);\n    for (let v = 0; v < variableSize; v++) {\n      // Read name\n      const name = readName(buffer);\n      // Read dimensionality of the variable\n      const dimensionality = buffer.readUint32();\n      // Index into the list of dimensions\n      const dimensionsIds = new Array(dimensionality);\n      for (let dim = 0; dim < dimensionality; dim++) {\n        dimensionsIds[dim] = buffer.readUint32();\n      }\n      // Read variables size\n      const attributes = attributesList(buffer);\n      // Read type\n      const type = buffer.readUint32();\n      notNetcdf(type < 1 && type > 6, `non valid type ${type}`);\n      // Read variable size\n      // The 32-bit varSize field is not large enough to contain the size of variables that require\n      // more than 2^32 - 4 bytes, so 2^32 - 1 is used in the varSize field for such variables.\n      const varSize = buffer.readUint32();\n      // Read offset\n      let offset = buffer.readUint32();\n      if (version === 2) {\n        notNetcdf(offset > 0, 'offsets larger than 4GB not supported');\n        offset = buffer.readUint32();\n      }\n      let record = false;\n      // Count amount of record variables\n      if (typeof recordId !== 'undefined' && dimensionsIds[0] === recordId) {\n        recordStep += varSize;\n        record = true;\n      }\n      variables[v] = {\n        name,\n        dimensions: dimensionsIds,\n        attributes,\n        type: num2str(type),\n        size: varSize,\n        offset,\n        record\n      };\n    }\n  }\n  return {\n    variables,\n    recordStep\n  };\n}","map":{"version":3,"names":["num2str","readType","padding","notNetcdf","readName","ZERO","NC_DIMENSION","NC_VARIABLE","NC_ATTRIBUTE","NC_UNLIMITED","header","buffer","version","recordDimension","length","readUint32","dimList","dimensionsList","Array","isArray","id","recordId","name","recordName","dimensions","globalAttributes","attributesList","variables","variablesList","recordStep","result","dimensionSize","dim","size","undefined","gAttList","attributes","attributeSize","gAtt","type","value","varList","variableSize","v","dimensionality","dimensionsIds","varSize","offset","record"],"sources":["E:\\Master2\\FYP\\Global\\Global\\dashboard_ComparisionVersion\\node_modules\\netcdfjs\\src\\header.ts"],"sourcesContent":["import { IOBuffer } from 'iobuffer';\n\nimport { num2str, readType } from './types';\nimport { padding, notNetcdf, readName } from './utils';\n\n// Grammar constants\nconst ZERO = 0;\nconst NC_DIMENSION = 10;\nconst NC_VARIABLE = 11;\nconst NC_ATTRIBUTE = 12;\nconst NC_UNLIMITED = 0;\n\nexport interface Header {\n  recordDimension: {\n    /**\n  Length of the record dimension\n  sum of the varSize's of all the record variables.\n  */\n    length: number;\n    id?: number;\n    name?: string;\n    recordStep?: number;\n  };\n  // Version\n  version: number;\n  /* List of dimensions*/\n  dimensions: Dimensions['dimensions'];\n  /* List of global attributes */\n  globalAttributes: Attribute[];\n  /* List of variables*/\n  variables: Variables['variables'];\n}\n/**\n * Reads the file header as @see {@link Header}\n * @param buffer - Buffer for the file data\n * @param version - Version of the file\n * @returns\n */\nexport function header(buffer: IOBuffer, version: number): Header {\n  const header: Partial<Header> = { version };\n\n  const recordDimension: Header['recordDimension'] = {\n    length: buffer.readUint32(),\n  };\n\n  const dimList = dimensionsList(buffer);\n\n  if (!Array.isArray(dimList)) {\n    recordDimension.id = dimList.recordId;\n    recordDimension.name = dimList.recordName;\n    header.dimensions = dimList.dimensions;\n  }\n\n  header.globalAttributes = attributesList(buffer);\n\n  const variables = variablesList(buffer, recordDimension?.id, version);\n  if (!Array.isArray(variables)) {\n    header.variables = variables.variables;\n    recordDimension.recordStep = variables.recordStep;\n  }\n\n  header.recordDimension = recordDimension;\n\n  return header as Header;\n}\n\nexport interface Dimensions {\n  /* that is an array of dimension object:*/\n  dimensions: Array<{\n    /* name of the dimension*/\n    name: string;\n    /* size of the dimension */\n    size: number;\n  }>;\n  /*  id of the dimension that has unlimited size or undefined,*/\n  recordId?: number;\n  /* name of the dimension that has unlimited size */\n  recordName?: string;\n}\n\n/**\n * List of dimensions\n * @param buffer - Buffer for the file data\n * @return List of dimensions\n */\nfunction dimensionsList(buffer: IOBuffer): Dimensions | [] {\n  const result: Partial<Dimensions> = {};\n  let recordId: number | undefined, recordName: string | undefined;\n\n  const dimList = buffer.readUint32();\n\n  let dimensions: Dimensions['dimensions'];\n\n  if (dimList === ZERO) {\n    notNetcdf(\n      buffer.readUint32() !== ZERO,\n      'wrong empty tag for list of dimensions',\n    );\n    return [];\n  } else {\n    notNetcdf(dimList !== NC_DIMENSION, 'wrong tag for list of dimensions');\n\n    // Length of dimensions\n    const dimensionSize = buffer.readUint32();\n    dimensions = new Array(dimensionSize);\n\n    //populate `name` and `size` for each dimension\n    for (let dim = 0; dim < dimensionSize; dim++) {\n      // Read name\n      const name = readName(buffer);\n\n      // Read dimension size\n      const size = buffer.readUint32();\n      if (size === NC_UNLIMITED) {\n        // in netcdf 3 one field can be of size unlimited\n        recordId = dim;\n        recordName = name;\n      }\n\n      dimensions[dim] = {\n        name,\n        size,\n      };\n    }\n  }\n  if (recordId !== undefined) {\n    result.recordId = recordId;\n  }\n  if (recordName !== undefined) {\n    result.recordName = recordName;\n  }\n  result.dimensions = dimensions;\n  return result as Dimensions;\n}\n\nexport interface Attribute {\n  /* name of the attribute */\n  name: string;\n  /* type of the attribute */\n  type: string;\n  /* value of the attribute */\n  value: number | string;\n}\n/**\n * List of attributes\n * @param buffer - Buffer for the file data\n * @return - List of attributes with:\n */\nfunction attributesList(buffer: IOBuffer): Attribute[] {\n  const gAttList = buffer.readUint32();\n  let attributes;\n  if (gAttList === ZERO) {\n    notNetcdf(\n      buffer.readUint32() !== ZERO,\n      'wrong empty tag for list of attributes',\n    );\n    return [];\n  } else {\n    notNetcdf(gAttList !== NC_ATTRIBUTE, 'wrong tag for list of attributes');\n\n    // Length of attributes\n    const attributeSize = buffer.readUint32();\n    attributes = new Array(attributeSize);\n    // Populate `name`, `type` and `value` for each attribute\n    for (let gAtt = 0; gAtt < attributeSize; gAtt++) {\n      // Read name\n      const name = readName(buffer);\n\n      // Read type\n      const type = buffer.readUint32();\n      notNetcdf(type < 1 || type > 6, `non valid type ${type}`);\n\n      // Read attribute\n      const size = buffer.readUint32();\n      const value = readType(buffer, type, size);\n\n      // Apply padding\n      padding(buffer);\n\n      attributes[gAtt] = {\n        name,\n        type: num2str(type),\n        value,\n      };\n    }\n  }\n  return attributes;\n}\n\nexport interface Variable {\n  /* name of the variable */\n  name: string;\n  /* Array with the dimension IDs of the variable*/\n  dimensions: number[];\n  /* Array with the attributes of the variable*/\n  attributes: [];\n  /* type of the variable*/\n  type: string;\n  /* size of the variable */\n  size: number;\n  /* offset where of the variable begins */\n  offset: number;\n  /* True if is a record variable, false otherwise (unlimited size) */\n  record: boolean;\n}\ninterface Variables {\n  variables: Variable[];\n  recordStep: number;\n}\n/**\n * @param buffer - Buffer for the file data\n * @param recordId - Id of the unlimited dimension (also called record dimension)\n * This value may be undefined if there is no unlimited dimension\n * @param version - Version of the file\n * @return - Number of recordStep and list of variables @see {@link Variables}\n */\nfunction variablesList(\n  buffer: IOBuffer,\n  recordId: number | undefined,\n  version: number,\n): Variables | [] {\n  const varList = buffer.readUint32();\n  let recordStep = 0;\n  let variables;\n  if (varList === ZERO) {\n    notNetcdf(\n      buffer.readUint32() !== ZERO,\n      'wrong empty tag for list of variables',\n    );\n    return [];\n  } else {\n    notNetcdf(varList !== NC_VARIABLE, 'wrong tag for list of variables');\n\n    // Length of variables\n    const variableSize = buffer.readUint32();\n    variables = new Array(variableSize);\n    for (let v = 0; v < variableSize; v++) {\n      // Read name\n      const name = readName(buffer);\n\n      // Read dimensionality of the variable\n      const dimensionality = buffer.readUint32();\n\n      // Index into the list of dimensions\n      const dimensionsIds = new Array(dimensionality);\n      for (let dim = 0; dim < dimensionality; dim++) {\n        dimensionsIds[dim] = buffer.readUint32();\n      }\n\n      // Read variables size\n      const attributes = attributesList(buffer);\n\n      // Read type\n      const type = buffer.readUint32();\n      notNetcdf(type < 1 && type > 6, `non valid type ${type}`);\n\n      // Read variable size\n      // The 32-bit varSize field is not large enough to contain the size of variables that require\n      // more than 2^32 - 4 bytes, so 2^32 - 1 is used in the varSize field for such variables.\n      const varSize = buffer.readUint32();\n\n      // Read offset\n      let offset = buffer.readUint32();\n      if (version === 2) {\n        notNetcdf(offset > 0, 'offsets larger than 4GB not supported');\n        offset = buffer.readUint32();\n      }\n\n      let record = false;\n      // Count amount of record variables\n      if (typeof recordId !== 'undefined' && dimensionsIds[0] === recordId) {\n        recordStep += varSize;\n        record = true;\n      }\n      variables[v] = {\n        name,\n        dimensions: dimensionsIds,\n        attributes,\n        type: num2str(type),\n        size: varSize,\n        offset,\n        record,\n      };\n    }\n  }\n  return {\n    variables,\n    recordStep,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}